# 今天可不是水题的一天哦

今天去打了杭电的OJ比赛，感觉不是一般的难，感觉也就2题可以做，早早的做完2题后就开始罚坐了，也是很难受啊；算了，不说了，看题吧；

### 题目

染染船长终于获得了宝藏！

宝藏是很多很多的金币（可以看成无穷多），染染需要与手下的 n*n* 名水手们分享金币。

根据大嘤帝国的传统，分配宝藏对于船长而言是一件稍不留神就会丧命的苦差事。这是由于，船长需要将每人能分到多少宝藏的决议公布，之后全体船员（包括船长）开会投票决定决议是否通过。如果半数及以上船员（包括船长）投票通过，船长就能够安全的执行决议；否则，船长就会被投海杀死，由第 11 顺位继承人继承船长的职位并再次分配，再不通过就继续投海杀死并由第 22 顺位继承人继承，依此类推。

好在经过多日的相处，染染知道手下的水手各个都是**聪明绝顶**又**贪婪**并且**相互之间了如指掌**的狠人！每个水手都会在**保证自己不被杀死的前提下**企图获得更大的利益。

现在，染染想要知道，如何分配给第 1,2,⋯,n1,2,⋯,*n* 顺位继承人的金币数量，才能保证自己只需要分出去最少的金币就能保住自己的性命。

Input

本题单个测试点内包含多组测试数据。

输入第一行一个正整数 T (1≤T≤20)*T* (1≤*T*≤20)，表示数据组数。

每组数据第一行一个正整数 n (1≤n≤109)*n* (1≤*n*≤109)，表示染染手下不包括他自己在内的水手数量。

Output

为了避免输出量过大，输出对每组数据进行压缩。

对于每组数据，假设染染分配给船长的第 i*i* 顺位继承人的金币数量为 ri*r**i*，你只需要输出一行一个压缩后的非负整数 R*R*：R=(∑i=1ni⋅ri)mod(109+7)*R*=(*i*=1∑*n**i*⋅*r**i*)mod(109+7)

可以证明序列 r1,r2,⋯,rn*r*1,*r*2,⋯,*r**n* 唯一。

### 题目分析

这是一道博弈论的题目，如果要发出去的金币最少，毫无疑问就算给也只会给1个金币，我们可以先分析人数少的情况，在推到人数多的情况，这样就可以了；代码中把1-6的情况都列举了一下；

```cpp
#include <bits/stdc++.h>
using namespace std;
/* run this program using the console pauser or add your own getch, system("pause") or input loop */
#define ll long long
const int mod=1e9+7;
void solve(){
	int n;
	cin>>n;
	ll x=n/2;
	ll ans=x*2+x*(x-1);
	ans=ans%mod;
	cout<<ans<<endl;
}
int main(int argc, char** argv) {
	ios::sync_with_stdio(0);
    cin.tie(0);
	int t;
	cin>>t;
	while(t--){
		solve();
	}
	return 0;
}
//1
//1
//0
//
//2
//1 2 
//0 1
//
//3
//1 2 3
//0 1 0
//
//4
//1 2 3 4
//0 1 0 1
//
//5
//1 2 3 4 5
//0 1 0 1 0
//
//6
//1 2 3 4 5 6
//1 0 1 0 1 0
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

